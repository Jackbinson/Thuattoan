/*Một thuật toán hiệu quả:
- Sử dụng tài nguyên thấp: Bộ nhớ lưu trữ (không gian), trang thiết bị,...
-Thời gian xử lý thấp (nhanh)
Phân tích dộ phức tạp tính toán(thời gian) của thuật toán:
-N là khối lượng dữ liệu cần xử lý
-Tính toán, đánh giá f(N) = số lượng tác vụ cơ bản
-Hai phương pháp đánh giá độ phức tạp của thuật toán:
  -Phương pháp thực nghiệm
  -Phương pháp xấp xỉ toán học.*/
  /*Giới thiệu thêm một số thuật toán sắp xếp đơn giản khác và cũng có độ phức tạp là O(n2)
  *Bubble sort
  *Insertion sort*/
 /*for (i = 1; i < n; i++) {
 j = i-1;
 while(j >= 0 && a[j]>a[i])}
 while(j >= 0 && a[j]>x
 {
 a[j+1]=a[j]
 j--;}
 a[j+1]=x)*/ 
 #include<iostream>
 using namespace std;
 void phanchia(int k, double a[],int n, double b[],int nb, double c[],int &nb, double )
 void merge_sort(double a[], int n)
 {
  int k;
  double b[100]; int nb;
  double b[100]; int nb;
  //buoc 1
  k = 1;
  while (k < n)
  {
    Phanchia(k,a,n,b,nb,c,nc);
    Trong(k,b,nb,c,nc,a,n);
    k *= 2; // k = k * 2;
  }
 }
 void phanchia(int k, day A, day &B, day &C )
 void tron(int k, day B, day C, day &A)
 void main() {
  double a[100]; int n;
  //Nhap day a gom n phan tu
  //goi ham merge_sort
  merge_sort(a,n);
  //xuat day a
 }